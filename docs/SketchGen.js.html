<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Code Generator/SketchGen.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Code Generator/SketchGen.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
var Sketch = Sketch || {};

/**
 * @classdesc Creates an instance of the SketchGen module. SketchGen takes a JSON tree output by the default Jison generated parser and outputs MVM bytecode used to drive computations and canvas operations.
 * @class Sketch.SketchGen
 * @public
 * @author FelixMcFelix (Kyle S.)
 */

Sketch.SketchGen = function(){
	var emit = function(code){
		outBuffer.push(code);
		programCounter++;
	}

	// TODO: convert to ENUM+Array based solution.

	var instructions = {
		//CONVENTION: All functions return an object with their return type. This is how we do type checking.

		//Program header.
		program: function(args){interpretNode(args);},

		//Variable declaration and assignment
		variable_decl: function(args){interpretNode(args);},
		variable_decl_assign: function(args){},
		decl: function(args){
			scopeRegister(args[1],args[0]); return args[0];
		},
		assign: function(args){
			var left = interpretNode(args[0]);
			var right = interpretNode(args[1]);
			emit(MVM.opCodes.STOREL);
			emit(left.data.entry.address);
			console.log(outBuffer);
			emit(MVM.opCodes.LOADL);
			emit(left.data.entry.address);
		},

		//Arithmetic instructions
		addition: function(args){interpretNode(args[0]);interpretNode(args[1]);emit(MVM.opCodes.IADD);},
		subtraction: function(args){interpretNode(args[0]);interpretNode(args[1]);emit(MVM.opCodes.ISUB);},
		multiplication: function(args){interpretNode(args[0]);interpretNode(args[1]);emit(MVM.opCodes.IMUL);},
		division: function(args){interpretNode(args[0]);interpretNode(args[1]);emit(MVM.opCodes.IDIV);},

		//Arithmetic assignment instructions.

		//Literals and identifiers.
		num: function(args){emit(MVM.opCodes.LOADC);emit(args);},
		ident: function(args){
			return {type: "ident", data: scopeLookup(args)};
		}
	}

	var outBuffer = [];
	var programCounter = 0;
	var scopeStack = [];
	var stackPtr = 0;

	var interpretNode = function(node){
		if(Array.isArray(node)){
			node.forEach(interpretNode);
		} else{
			return instructions[node.type](node.arguments);
		}
	};

	var scopePush = function(){
		scopeStack.push(new Sketch.SketchGen.ScopeStackFrame());
		stackPtr++;
	};

	var scopePop = function(){
		scopeStack.pop();
		stackPtr--;

		// TODO: Patch missed function calls (equivalent to hoisting).
		// TODO: Handle missed variable lookups in a different manner.
	};

	var scopeRegister = function(label, type, extra){
		var curFrame = scopeStack[stackPtr];

		if (!curFrame.labelTable[label]){
			var destAddr = (type === "function") ? programCounter : curFrame.nextData++;
			curFrame.labelTable[label] = new Sketch.SketchGen.Label(destAddr, type);
		} else {
			throw "Illegal attempt to redefine variable "+label+".";
		}
	};

	var scopeLookup = function(label){
		var stack = 0;
		var out = null;

		for(null; stackPtr-stack>=0; stack++){
			var frame = scopeStack[stackPtr-stack];
			var entry = frame.labelTable[label];
			if (entry){
				out = {entry: entry, stack: stack};
				break;
			}
		}

		// TODO: Track lookup failures to patch function calls.

		return out;
	};

	/**
	 * Compile a Sketch program.
	 * @method Sketch.Driver#compile
	 * @param {Object} program - an AST object generated by 
	 * @returns number[] - an array of opcodes and literals to be parsed by MVM.
	 * @public
	 */
	this.interpret = function(program){
		this.cleanState();

		// this.testStack();

		interpretNode({type: "program", arguments: program});
		return outBuffer;
	};

	this.cleanState = function(){
		outBuffer = [];
		programCounter = 0;
		scopeStack = [];
		scopePush();
		stackPtr = 0;
	}

	this.testStack = function(){
		//Test stack architecture
		scopeRegister("globalInt", "int")
		scopePush();
		scopeRegister("intA", "int");
		scopeRegister("intB", "int");

		console.log("Registered a higher up int as well as two closer ones.");

		console.log("Performing a lookup for each entry. Expect \n\t{entry:{address:0, type:\"int\"}, stack: 1}\n\t{entry:{address:1, type:\"int\"}, stack: 0}");
		console.log(scopeLookup("globalInt"));
		console.log(scopeLookup("intB"));

		console.log("Performing a double registration.");
		try {
			scopeRegister("intA", "int");
			console.log("Double registration of intA succeeded, something broke!");
		} catch (e) {
			console.log("Double registration of intA threw, as expected.");
		}

		console.log("Testing override of globalInt with a float. Expect \n\t{entry:{address:2, type:\"float\"}, stack: 0}");
		scopeRegister("globalInt", "float");
		console.log(scopeLookup("globalInt"));

		console.log("Testing failed lookup.");
		console.log(scopeLookup("notReal"));

		console.log(scopeStack);

		scopePop();

		//End test
	}
}

/**
 * @classdesc Simple semantic class for use in the {@link Sketch.SketchGen} scope stack.
 * @class Sketch.SketchGen.ScopeStackFrame
 * @public
 * @author FelixMcFelix (Kyle S.)
 */
Sketch.SketchGen.ScopeStackFrame = function(){
	this.labelTable = {};
	this.nextData = 0;
}

/**
 * @classdesc Simple semantic class for use in the {@link Sketch.SketchGen.ScopeStackFrame} label table.
 * @class Sketch.SketchGen.Label
 * @public
 * @param {Number} addr - the address the label references within its data frame.
 * @param {String} type - the type of the variable represented by the label.
 * @param {Object} [extra] - any extra data (function parameters etc.) that must be known about the label.
 * @author FelixMcFelix (Kyle S.)
 */
Sketch.SketchGen.Label = function(addr, type, extra){
	this.address = addr;
	this.type = type;
	if(extra){
		this.extra = extra;
	}
}

Sketch.SketchGen.enume = "test";</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="Palette.Manager.html">Manager</a></li><li><a href="Palette.Program.html">Program</a></li><li><a href="Palette.Shader.html">Shader</a></li><li><a href="Palette.ShaderFactory.html">ShaderFactory</a></li><li><a href="Sketch.Driver.html">Driver</a></li><li><a href="Sketch.SketchGen.html">SketchGen</a></li><li><a href="Sketch.SketchGen.Label.html">Label</a></li><li><a href="Sketch.SketchGen.ScopeStackFrame.html">ScopeStackFrame</a></li></ul><h3>Namespaces</h3><ul><li><a href="Palette.html">Palette</a></li><li><a href="Sketch.html">Sketch</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Tue Sep 15 2015 16:49:44 GMT+0100 (GMT Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
